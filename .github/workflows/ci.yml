Monolithic CI/CD Workflow
A robust and resilient pipeline for GitHub Actions, all in a single job.

Copy Script
# .github/workflows/ci.yml
# Name of the workflow displayed on the GitHub Actions tab
name: Superlab Monolithic CI/CD Pipeline

# Controls when the workflow will run
on:
  # Triggers the workflow on push events but only for the "main" branch
  push:
    branches: [ "main" ]
  
  # Triggers the workflow on pull request events for the "main" branch
  pull_request:
    branches: [ "main" ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of a single, powerful job
jobs:
  ci-pipeline:
    name: "Complete CI/CD Pipeline"
    runs-on: ubuntu-latest
    
    # Ensures the pipeline proceeds even if a dependent job fails, or a dependency is not met.
    # This addresses the "not get stopped" requirement for continuous tasks.
    continue-on-error: true
    
    steps:
      # Step 1: Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Fetches all history for all branches and tags.
          # This is crucial for deep analysis and prevents a shallow clone from causing failures.
          fetch-depth: 0

      # Step 2: Setup Node.js - Uses a matrix-like approach with 'steps'
      - name: Setup Node.js v18
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
      
      # Step 3: Install Dependencies
      - name: Install Dependencies
        run: npm ci

      # Step 4: Run Linter
      - name: Run Linter
        run: npm run lint || echo "Linting failed, but continuing the pipeline as requested."

      # Step 5: Build Project
      - name: Build Project
        run: npm run build --if-present

      # Step 6: Run Tests
      - name: Run Tests
        run: npm run test --if-present

      # Step 7: A Comprehensive Security Scan (example with a well-known action)
      # This step can be replaced with more specific scanning tools like Snyk, SonarCloud, etc.
      - name: Run Trivy Vulnerability Scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          ignore-unfixed: true
          format: 'table'
          # This is a key part of ensuring the pipeline "cannot be stopped" by a failure
          exit-code: '0' 
      
      # Step 8: Dockerize the application
      - name: Docker Login
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
        continue-on-error: true

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/your-app:latest
        continue-on-error: true

      # Step 9: Deploy to a Staging environment (placeholder)
      # This step will still run even if previous steps fail, fulfilling the continuous flow requirement.
      - name: Deploy to Staging
        env:
          MY_VAR: 'This deployment is proceeding.'
        run: |
          echo "Deploying to Staging..."
          echo "Example of a command that will run regardless of previous errors."
          echo $MY_VAR
        continue-on-error: true
        
      # Step 10: Run on a second Node.js version
      # A single-job "monolithic" approach can be extended this way
      - name: Setup Node.js v20 for additional checks
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
        continue-on-error: true

      - name: Run additional tests on v20
        run: npm run test-coverage || true
        continue-on-error: true
