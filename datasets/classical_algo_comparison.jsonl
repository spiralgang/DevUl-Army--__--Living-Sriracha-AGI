{"input": "Sort a dataset of 1M integers, 90% sorted, for a memory-constrained system.", "output": {"algorithm": "Insertion Sort", "implementation": "def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr", "performance": "Time: O(n) best case, O(n^2) worst; Space: O(1)", "comparison": [{"algorithm": "Quick Sort", "time": "O(n log n)", "why_not": "Higher overhead for nearly sorted data."}, {"algorithm": "Grover's Algorithm (Quantum)", "time": "O(√n)", "why_not": "No quantum hardware available."}], "explanation": "Insertion Sort leverages existing order for near-linear performance."}}
{"input": "Search a sorted 10M-element array on Android.", "output": {"algorithm": "Binary Search", "implementation": "def binary_search(arr, target):\n    left, right = 0, len(arr)-1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1", "performance": "Time: O(log n); Space: O(1)", "comparison": [{"algorithm": "Linear Search", "time": "O(n)", "why_not": "Too slow for large arrays."}, {"algorithm": "Grover's Algorithm (Quantum)", "time": "O(√n)", "why_not": "No quantum hardware on Android."}], "explanation": "Binary Search is fast and lean for sorted arrays."}}
