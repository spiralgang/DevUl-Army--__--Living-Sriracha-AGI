{"input": "Sort a dataset of 1M integers, 90% sorted, for a memory-constrained system.", "output": {"algorithm": "Insertion Sort", "implementation": "def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr", "performance": "Time: O(n) best case, O(n^2) worst; Space: O(1)", "comparison": [{"algorithm": "Quick Sort", "time": "O(n log n)", "why_not": "Higher overhead for nearly sorted data due to pivot selection."}, {"algorithm": "Merge Sort", "time": "O(n log n)", "why_not": "Requires O(n) extra space, less efficient for in-place sorting."}, {"algorithm": "Grover's Algorithm (Quantum)", "time": "O(√n)", "why_not": "No quantum hardware available, overkill for sorting."}], "explanation": "Insertion Sort leverages existing order for near-linear performance on mostly sorted data."}}
{"input": "Search a sorted 10M-element array on Android.", "output": {"algorithm": "Binary Search", "implementation": "def binary_search(arr, target):\n    left, right = 0, len(arr)-1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1", "performance": "Time: O(log n); Space: O(1)", "comparison": [{"algorithm": "Linear Search", "time": "O(n)", "why_not": "Too slow for large arrays."}, {"algorithm": "Grover's Algorithm (Quantum)", "time": "O(√n)", "why_not": "No quantum hardware on Android."}], "explanation": "Binary Search is fast and lean for sorted arrays, no quantum needed."}}
{"input": "Find shortest path in a 1000-node graph for navigation app.", "output": {"algorithm": "Dijkstra's Algorithm", "implementation": "import heapq\n\ndef dijkstra(graph, start, end):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_distance, current = heapq.heappop(pq)\n        if current == end:\n            return current_distance\n        \n        for neighbor, weight in graph[current].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return float('inf')", "performance": "Time: O((V + E) log V); Space: O(V)", "comparison": [{"algorithm": "A* Algorithm", "time": "O(b^d)", "why_not": "Requires heuristic function, more complex for general case."}, {"algorithm": "Quantum Walk", "time": "O(√N)", "why_not": "No quantum hardware, impractical for mobile."}], "explanation": "Dijkstra's is optimal for weighted graphs without heuristics."}}
{"input": "Optimize matrix multiplication for 500x500 matrices on mobile CPU.", "output": {"algorithm": "Strassen's Algorithm", "implementation": "def strassen_multiply(A, B):\n    n = len(A)\n    if n <= 64:  # Base case for mobile optimization\n        return standard_multiply(A, B)\n    \n    # Divide matrices into quadrants\n    mid = n // 2\n    A11, A12, A21, A22 = split_matrix(A, mid)\n    B11, B12, B21, B22 = split_matrix(B, mid)\n    \n    # 7 recursive multiplications\n    M1 = strassen_multiply(add_matrices(A11, A22), add_matrices(B11, B22))\n    M2 = strassen_multiply(add_matrices(A21, A22), B11)\n    M3 = strassen_multiply(A11, subtract_matrices(B12, B22))\n    M4 = strassen_multiply(A22, subtract_matrices(B21, B11))\n    M5 = strassen_multiply(add_matrices(A11, A12), B22)\n    M6 = strassen_multiply(subtract_matrices(A21, A11), add_matrices(B11, B12))\n    M7 = strassen_multiply(subtract_matrices(A12, A22), add_matrices(B21, B22))\n    \n    # Combine results\n    C11 = add_matrices(subtract_matrices(add_matrices(M1, M4), M5), M7)\n    C12 = add_matrices(M3, M5)\n    C21 = add_matrices(M2, M4)\n    C22 = add_matrices(subtract_matrices(add_matrices(M1, M3), M2), M6)\n    \n    return combine_matrices(C11, C12, C21, C22)", "performance": "Time: O(n^2.807); Space: O(n^2)", "comparison": [{"algorithm": "Standard Matrix Multiplication", "time": "O(n^3)", "why_not": "Too slow for large matrices."}, {"algorithm": "Quantum Matrix Multiplication", "time": "O(n^2.373)", "why_not": "No quantum hardware on mobile devices."}], "explanation": "Strassen's reduces complexity while being implementable on classical hardware."}}
{"input": "Compress text data for storage-limited Android app.", "output": {"algorithm": "Huffman Coding", "implementation": "import heapq\nfrom collections import defaultdict, Counter\n\nclass HuffmanNode:\n    def __init__(self, char, freq):\n        self.char = char\n        self.freq = freq\n        self.left = None\n        self.right = None\n    \n    def __lt__(self, other):\n        return self.freq < other.freq\n\ndef huffman_encode(text):\n    if not text:\n        return '', {}\n    \n    # Build frequency table\n    freq = Counter(text)\n    \n    # Build heap\n    heap = [HuffmanNode(char, freq) for char, freq in freq.items()]\n    heapq.heapify(heap)\n    \n    # Build tree\n    while len(heap) > 1:\n        left = heapq.heappop(heap)\n        right = heapq.heappop(heap)\n        \n        merged = HuffmanNode(None, left.freq + right.freq)\n        merged.left = left\n        merged.right = right\n        \n        heapq.heappush(heap, merged)\n    \n    # Generate codes\n    codes = {}\n    if heap:\n        generate_codes(heap[0], '', codes)\n    \n    # Encode text\n    encoded = ''.join(codes[char] for char in text)\n    return encoded, codes", "performance": "Time: O(n log n); Space: O(n)", "comparison": [{"algorithm": "LZ77", "time": "O(n)", "why_not": "More complex implementation, larger memory footprint."}, {"algorithm": "Quantum Compression", "time": "O(log n)", "why_not": "No quantum hardware available on Android."}], "explanation": "Huffman coding provides optimal prefix-free compression for known frequency distributions."}}